# siamCenter.pyimport wximport guiimport apiimport uiimport osimport jsonimport addonHandlerfrom . import settingManagerimport coreimport shutilimport globalVarsimport reimport timeaddonHandler.initTranslation()class AddWordDialog(wx.Dialog):    def __init__(self, parent, word="", definition="", edit_mode=False):        title = _("แก้ไขคำ") if edit_mode else _("เพิ่มคำ")        super(AddWordDialog, self).__init__(parent, title=title, size=(500, 400))        self.word = word        self.definition = definition        self.edit_mode = edit_mode        self.main_sizer = wx.BoxSizer(wx.VERTICAL)        self.create_controls()        self.SetSizer(self.main_sizer)        self.CentreOnScreen()    def create_controls(self):        # Word input        word_label = wx.StaticText(self, label=_("คำ:"))        self.main_sizer.Add(word_label, 0, wx.ALL, 5)                self.word_ctrl = wx.TextCtrl(self)        self.word_ctrl.SetValue(self.word)        self.main_sizer.Add(self.word_ctrl, 0, wx.EXPAND | wx.ALL, 5)        # Definition input        definition_label = wx.StaticText(self, label=_("ความหมาย:"))        self.main_sizer.Add(definition_label, 0, wx.ALL, 5)                self.definition_ctrl = wx.TextCtrl(self, style=wx.TE_MULTILINE, size=(-1, 200))        self.definition_ctrl.SetValue(self.definition)        self.main_sizer.Add(self.definition_ctrl, 1, wx.EXPAND | wx.ALL, 5)        # Buttons        button_sizer = wx.BoxSizer(wx.HORIZONTAL)                if self.edit_mode:            save_button = wx.Button(self, wx.ID_ANY, label=_("แก้ไขคำ"))        else:            save_button = wx.Button(self, wx.ID_ANY, label=_("เพิ่มคำ"))        save_button.Bind(wx.EVT_BUTTON, self.on_save)        button_sizer.Add(save_button, 0, wx.ALL, 5)        cancel_button = wx.Button(self, wx.ID_CANCEL, label=_("ยกเลิก"))        button_sizer.Add(cancel_button, 0, wx.ALL, 5)                self.main_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)        # Bind ESC key to close dialog        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)                self.word_ctrl.SetFocus()    def on_save(self, event):        word = self.word_ctrl.GetValue().strip()        definition = self.definition_ctrl.GetValue().strip()                if not word:            wx.MessageBox(_("กรุณากรอกคำ"), _("ข้อผิดพลาด"), wx.OK | wx.ICON_ERROR)            return                    if not definition:            wx.MessageBox(_("กรุณากรอกความหมาย"), _("ข้อผิดพลาด"), wx.OK | wx.ICON_ERROR)            return                self.word = word        self.definition = definition        self.EndModal(wx.ID_OK)    def on_char_hook(self, event):        if event.GetKeyCode() == wx.WXK_ESCAPE:            self.EndModal(wx.ID_CANCEL)        else:            event.Skip()class SiamCenterDialog(wx.Dialog):    def __init__(self, parent, selected_word=None):        super(SiamCenterDialog, self).__init__(parent, title=_("Siam Center"), size=(800, 600))        self.settingManager = settingManager.SettingManager()        self.dictionary = {}        self.selected_word = selected_word        self.jump_word_prefix = ""  # For incremental search        self.last_key_time = 0.0  # Time stamp for prefix timeout        self.load_dictionary()        self.current_category = ""        self.current_word = ""        self.main_sizer = wx.BoxSizer(wx.VERTICAL)        self.create_controls()        self.SetSizer(self.main_sizer)        self.CentreOnScreen()                # Auto-select word if provided        if self.selected_word:            self.auto_select_word(self.selected_word)    def load_dictionary(self):        """Load dictionary from user config location (primary source for edits)"""        self.dictionary = {}                # Determine the user config directory path (e.g., nvda/userConfig/)        user_config_dir = globalVars.appArgs.configPath                # Primary location: User config directory (for user additions/edits and backup)        backup_dir = os.path.join(user_config_dir, "siamSquare")        backup_path = os.path.join(backup_dir, "thaiDic.jsonl")                # Secondary location: Addon directory (for default/initial dictionary)        addonPath = os.path.abspath(os.path.dirname(__file__))        dictPath = os.path.join(addonPath, "dictionary", "thaiDic.jsonl")                load_path = None                # 1. Try to load from User Config (most important and persistent)        if os.path.exists(backup_path):            load_path = backup_path        # 2. Fallback to Addon Default        elif os.path.exists(dictPath):            load_path = dictPath                try:            if load_path:                with open(load_path, 'r', encoding='utf-8') as f:                    for line in f:                        try:                            entry = json.loads(line.strip())                            for word, definitions in entry.items():                                self.dictionary[word] = definitions                        except json.JSONDecodeError:                            continue        except Exception as e:            ui.message(_("เกิดข้อผิดพลาดในการโหลดพจนานุกรม: {}").format(str(e)))    def save_dictionary(self):        """Save dictionary to user config location and optionally to addon location"""        try:            # Determine the user config directory path (e.g., nvda/userConfig/)            user_config_dir = globalVars.appArgs.configPath                        # 1. Save to backup location (user config) - this is the persistent storage            backup_dir = os.path.join(user_config_dir, "siamSquare")            os.makedirs(backup_dir, exist_ok=True)            backup_path = os.path.join(backup_dir, "thaiDic.jsonl")                        # Save sorted dictionary to backup location            with open(backup_path, 'w', encoding='utf-8') as f:                for word in sorted(self.dictionary.keys()):                    entry = {word: self.dictionary[word]}                    f.write(json.dumps(entry, ensure_ascii=False) + '\n')                        # 2. Optionally save to addon directory (as an additional backup/for distribution)            if self.backup_checkbox.IsChecked():                addonPath = os.path.abspath(os.path.dirname(__file__))                dictPath = os.path.join(addonPath, "dictionary", "thaiDic.jsonl")                # Ensure the directory exists                os.makedirs(os.path.dirname(dictPath), exist_ok=True)                # Copy the file                shutil.copy2(backup_path, dictPath)                        # 3. Reload the dictionary in the core module immediately            self.reload_core_dictionary()                        return True        except Exception as e:            ui.message(_("เกิดข้อผิดพลาดในการบันทึกพจนานุกรม: {}").format(str(e)))            return False    def reload_core_dictionary(self):        """Reload dictionary in the core module without restarting NVDA"""        try:            # Get the global plugin instance and reload its dictionary            from . import siamSquareCore            import globalPluginHandler            plugin = globalPluginHandler.getGlobalPluginInstance()            if plugin and hasattr(plugin, 'siamSquareCore'):                # Update the core dictionary reference                plugin.siamSquareCore.dictionary = self.dictionary.copy()                ui.message(_("พจนานุกรมถูกโหลดใหม่เรียบร้อยแล้ว"))        except Exception as e:            print(f"Error reloading core dictionary: {e}")    def get_thai_first_consonant(self, word):        """Extracts the initial consonant of a Thai word, ignoring leading vowels."""        # Regex to find the first consonant (ก-ฮ) in the word        match = re.search(r'[ก-ฮ]', word)        if match:            return match.group(0)        return None    def auto_select_word(self, word):        if not word:            return                    # Get the first consonant, ignoring leading vowels like โ, แ, เ, etc.        first_consonant = self.get_thai_first_consonant(word)                if first_consonant:            categories = self.get_thai_initial_consonants()                        if first_consonant in categories:                index = categories.index(first_consonant)                self.category_list.SetSelection(index)                self.current_category = first_consonant                # Update word list and select the word after a slight delay                wx.CallLater(100, self.update_word_list_after_selection, word)            else:                ui.message(_("ไม่พบหมวดสำหรับพยัญชนะต้น: {}").format(first_consonant))    def update_word_list_after_selection(self, target_word):        self.update_word_list()                # Find and select the word        words = self.word_list.GetStrings()        for i, word in enumerate(words):            if word == target_word:                self.word_list.SetSelection(i)                self.current_word = word                # Focus the word list and announce                self.word_list.SetFocus()                wx.CallLater(100, self.update_definition_list)                break        else:            ui.message(_("ไม่พบคำว่า: {} ในพจนานุกรม").format(target_word))    def create_controls(self):        # Category selection        category_label = wx.StaticText(self, label=_("หมวด:"))        self.main_sizer.Add(category_label, 0, wx.ALL, 5)                self.category_list = wx.ListBox(self, choices=self.get_thai_initial_consonants(), style=wx.LB_SINGLE)        self.category_list.Bind(wx.EVT_LISTBOX, self.on_category_select)        self.main_sizer.Add(self.category_list, 0, wx.EXPAND | wx.ALL, 5)        # Word list        word_label = wx.StaticText(self, label=_("คำ:"))        self.main_sizer.Add(word_label, 0, wx.ALL, 5)                self.word_list = wx.ListBox(self, style=wx.LB_SINGLE)        self.word_list.Bind(wx.EVT_LISTBOX, self.on_word_select)        self.word_list.Bind(wx.EVT_CONTEXT_MENU, self.on_word_context_menu)        self.word_list.Bind(wx.EVT_CHAR, self.on_word_list_char)        self.main_sizer.Add(self.word_list, 1, wx.EXPAND | wx.ALL, 5)        # Definition list        definition_label = wx.StaticText(self, label=_("ความหมาย:"))        self.main_sizer.Add(definition_label, 0, wx.ALL, 5)                self.definition_list = wx.ListBox(self, style=wx.LB_SINGLE)        self.definition_list.Bind(wx.EVT_CONTEXT_MENU, self.on_definition_context_menu)        self.main_sizer.Add(self.definition_list, 1, wx.EXPAND | wx.ALL, 5)        # Action buttons        action_sizer = wx.BoxSizer(wx.HORIZONTAL)                self.add_button = wx.Button(self, wx.ID_ANY, label=_("เพิ่มคำ"))        self.add_button.Bind(wx.EVT_BUTTON, self.on_add_word)        action_sizer.Add(self.add_button, 0, wx.ALL, 5)        self.edit_button = wx.Button(self, wx.ID_ANY, label=_("แก้ไขคำ"))        self.edit_button.Bind(wx.EVT_BUTTON, self.on_edit_word)        action_sizer.Add(self.edit_button, 0, wx.ALL, 5)                # Backup checkbox (Controls copying from User Config to Add-on dir)        self.backup_checkbox = wx.CheckBox(self, label=_("สำรองไฟล์พจนานุกรมในโฟลเดอร์ Add-on"))        self.backup_checkbox.SetValue(True)         action_sizer.Add(self.backup_checkbox, 0, wx.ALL, 5)                self.main_sizer.Add(action_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)        # Close button        button_sizer = wx.BoxSizer(wx.HORIZONTAL)        close_button = wx.Button(self, wx.ID_CLOSE, label=_("ปิด"))        close_button.Bind(wx.EVT_BUTTON, lambda evt: self.Close())        button_sizer.Add(close_button, 0, wx.ALL, 5)        self.main_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)        # Bind ESC key and character hook for jump to word        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)    def get_thai_initial_consonants(self):        return ["ก", "ข", "ค", "ฆ", "ง", "จ", "ฉ", "ช", "ซ", "ฌ", "ญ", "ฎ", "ฏ", "ฐ", "ฑ", "ฒ", "ณ", "ด", "ต", "ถ", "ท", "ธ", "น", "บ", "ป", "ผ", "ฝ", "พ", "ฟ", "ภ", "ม", "ย", "ร", "ล", "ว", "ศ", "ษ", "ส", "ห", "ฬ", "อ", "ฮ"]    def on_category_select(self, event):        self.current_category = self.category_list.GetStringSelection()        wx.CallLater(1, self.update_word_list)        self.jump_word_prefix = ""  # Clear jump prefix on category change    def update_word_list(self):        self.word_list.Clear()        self.definition_list.Clear()        if not self.current_category:            return                    words_in_category = []        for word in self.dictionary.keys():            # Check if the first consonant matches the current category            if word and self.get_thai_first_consonant(word) == self.current_category:                words_in_category.append(word)                words_in_category.sort()        self.word_list.Set(words_in_category)    def on_word_select(self, event):        self.current_word = self.word_list.GetStringSelection()        wx.CallLater(1, self.update_definition_list)    def update_definition_list(self):        self.definition_list.Clear()        if not self.current_word:            return                    definitions = self.dictionary.get(self.current_word, [])        definition_texts = []                for definition_group in definitions:            for definition in definition_group:                definition_texts.append(definition)                self.definition_list.Set(definition_texts)    def on_add_word(self, event):        dialog = AddWordDialog(self)        if dialog.ShowModal() == wx.ID_OK:            word = dialog.word            definition = dialog.definition                        # Add to dictionary            self.dictionary[word] = [[definition]]                        # Save dictionary (which includes backup and core reload)            if self.save_dictionary():                ui.message(_("เพิ่มคำลงพจนานุกรมสมบูรณ์"))                # Refresh the display and try to select the new word                first_consonant = self.get_thai_first_consonant(word)                if first_consonant == self.current_category:                    self.update_word_list_after_selection(word)                else:                    # Switch category if needed                    categories = self.get_thai_initial_consonants()                    if first_consonant in categories:                        index = categories.index(first_consonant)                        self.category_list.SetSelection(index)                        self.current_category = first_consonant                        self.update_word_list_after_selection(word)            else:                ui.message(_("เกิดข้อผิดพลาดในการเพิ่มคำ"))                dialog.Destroy()    def on_edit_word(self, event):        if not self.current_word:            wx.MessageBox(_("กรุณาเลือกคำที่ต้องการแก้ไข"), _("ข้อผิดพลาด"), wx.OK | wx.ICON_ERROR)            return                    definitions = self.dictionary.get(self.current_word, [])        definition_text = ""        if definitions:            definition_text = "\n".join(definitions[0])                    dialog = AddWordDialog(self, self.current_word, definition_text, edit_mode=True)        if dialog.ShowModal() == wx.ID_OK:            new_word = dialog.word            new_definition = dialog.definition                        # Get consonants before removal/addition            old_consonant = self.get_thai_first_consonant(self.current_word)            new_consonant = self.get_thai_first_consonant(new_word)                        # Remove old word if name changed            if new_word != self.current_word:                del self.dictionary[self.current_word]                        # Add/update word            self.dictionary[new_word] = [[new_definition]]                        # Save dictionary (which includes backup and core reload)            if self.save_dictionary():                ui.message(_("แก้ไขคำสมบูรณ์"))                # Refresh the display                if new_consonant == old_consonant:                    self.current_category = new_consonant                    self.update_word_list_after_selection(new_word)                else:                    # Switch to new category if needed                    categories = self.get_thai_initial_consonants()                    if new_consonant in categories:                        index = categories.index(new_consonant)                        self.category_list.SetSelection(index)                        self.current_category = new_consonant                        self.update_word_list_after_selection(new_word)            else:                ui.message(_("เกิดข้อผิดพลาดในการแก้ไขคำ"))                dialog.Destroy()    def on_word_context_menu(self, event):        menu = wx.Menu()        copy_item = menu.Append(wx.ID_ANY, _("คัดลอกคำ"))        self.Bind(wx.EVT_MENU, self.on_copy_word, copy_item)        self.PopupMenu(menu)        menu.Destroy()    def on_definition_context_menu(self, event):        menu = wx.Menu()        copy_item = menu.Append(wx.ID_ANY, _("คัดลอกความหมาย"))        self.Bind(wx.EVT_MENU, self.on_copy_definition, copy_item)        menu.AppendSeparator()        copy_all_item = menu.Append(wx.ID_ANY, _("คัดลอกคำและความหมายทั้งหมด"))        self.Bind(wx.EVT_MENU, self.on_copy_word_and_definition, copy_all_item)        self.PopupMenu(menu)        menu.Destroy()    def on_copy_word(self, event):        selected_word = self.word_list.GetStringSelection()        if selected_word:            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(selected_word))                wx.TheClipboard.Close()                ui.message(_("คัดลอกคำ: {}").format(selected_word))            else:                ui.message(_("ไม่สามารถเปิดคลิปบอร์ดได้"))    def on_copy_definition(self, event):        selected_definition = self.definition_list.GetStringSelection()        if selected_definition:            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(selected_definition))                wx.TheClipboard.Close()                ui.message(_("คัดลอกความหมายเรียบร้อย"))            else:                ui.message(_("ไม่สามารถเปิดคลิปบอร์ดได้"))    def on_copy_word_and_definition(self, event):        selected_word = self.word_list.GetStringSelection()        selected_definition = self.definition_list.GetStringSelection()        if selected_word and selected_definition:            text = f"{selected_word}: {selected_definition}"            if wx.TheClipboard.Open():                wx.TheClipboard.SetData(wx.TextDataObject(text))                wx.TheClipboard.Close()                ui.message(_("คัดลอกคำและความหมายเรียบร้อย"))            else:                ui.message(_("กรุณาเลือกคำและความหมาย"))    def on_char_hook(self, event):        key = event.GetKeyCode()        if key == wx.WXK_ESCAPE:            self.Close()        else:            event.Skip()    def on_word_list_char(self, event):        key = event.GetUnicodeKey()        if key == wx.WXK_NONE:            event.Skip()            return                # Ensure word_list has focus to avoid processing unintended key events        if self.word_list.HasFocus():            current_time = time.time()                        # Handle incremental search for Thai characters (consonants, vowels, tone marks)            if 0x0E01 <= key <= 0x0E5B:  # Thai characters (Unicode range for Thai)                char = chr(key)                if current_time - self.last_key_time > 1.0:                    self.jump_word_prefix = ""                self.jump_word_prefix += char                self.last_key_time = current_time                                # Find the first word starting with the prefix                words = self.word_list.GetStrings()                for i, word in enumerate(words):                    if word.startswith(self.jump_word_prefix):                        self.word_list.SetSelection(i)                        self.current_word = word                        self.update_definition_list()                        ui.message(_("{}").format(word))                        break                else:                    self.jump_word_prefix = self.jump_word_prefix[:-1]  # Remove last char if no match                    ui.message(_("ไม่พบคำที่เริ่มด้วย: {}").format(self.jump_word_prefix))            else:                event.Skip()        else:            event.Skip()