# siamSquareCore.py# Copyright (C) 2025 ['chai chaimee']# Licensed under GNU General Public License. See COPYING.txt for details.import jsonimport osimport reimport globalVarsimport uiimport wximport guiimport textInfosimport apiimport timeimport coreimport watchdogfrom keyboardHandler import KeyboardInputGestureimport braillefrom logHandler import logimport speechclass SiamSquareCore:    def __init__(self, setting_manager):        self.setting_manager = setting_manager        self.dictionary = {}        self.load_dictionary()    def load_dictionary(self):        """Load dictionary from user config or addon directory"""        self.dictionary = {}        user_config_dir = globalVars.appArgs.configPath        backup_dir = os.path.join(user_config_dir, "siamSquare")        backup_path = os.path.join(backup_dir, "thaiDic.jsonl")        addon_path = os.path.abspath(os.path.dirname(__file__))        dict_path = os.path.join(addon_path, "dictionary", "thaiDic.jsonl")                load_path = backup_path if os.path.exists(backup_path) else dict_path                try:            if os.path.exists(load_path):                with open(load_path, 'r', encoding='utf-8') as f:                    for line in f:                        try:                            entry = json.loads(line.strip())                            for word, definitions in entry.items():                                self.dictionary[word] = definitions                        except json.JSONDecodeError:                            continue        except Exception as e:            ui.message(_("เกิดข้อผิดพลาดในการโหลดพจนานุกรม: {}").format(str(e)))    def announceWordDefinition(self, word):        """Announce the definition of the given word"""        word = word.strip()        if not word:            ui.message(_("ไม่มีคำให้ค้นหาความหมาย"))            return                    definitions = self.dictionary.get(word, [])        if definitions:            definition_text = ""            for group in definitions:                for definition in group:                    definition_text += definition + "\n"            ui.message(definition_text.strip())        else:            ui.message(_("ไม่พบความหมายของคำ: {}").format(word))    def showWordSuggestionsDialog(self, textInfo, currentWord):        currentWord = currentWord.strip()                if not currentWord:            ui.message(_("ไม่มีคำที่ตำแหน่งเคอร์เซอร์หรือไม่ได้เลือกข้อความ"))            return        suggestions = self.getWordSuggestions(currentWord)                if not suggestions:            ui.message(_("ไม่มีคำแนะนำสำหรับ: {}").format(currentWord))            return        def replace_word(newWord):            # Schedule the word replacement to happen on the main thread            wx.CallAfter(self.replaceWord, textInfo, newWord)        wx.CallAfter(self._showDialog_safe, suggestions, replace_word)    def replaceWord(self, textInfo, newWord):        """Replaces the text range defined by textInfo with newWord using multiple methods like xBlock"""        try:            # First try to set text directly            try:                textInfo.text = newWord                ui.message(_("แทนที่ด้วยคำว่า: {}").format(newWord))                return            except Exception:                pass                        # If direct text setting fails, use clipboard method like xBlock            try:                clipboardBackup = api.getClipData()            except OSError:                clipboardBackup = None                        try:                api.copyToClip(newWord)                time.sleep(0.1 if clipboardBackup is None else 0.01)                api.processPendingEvents(False)            except Exception as e:                ui.message(_("ไม่สามารถคัดลอกคำไปยังคลิปบอร์ดได้"))                return                        # Try to focus the object and paste            focus = api.getFocusObject()            try:                # First try standard Ctrl+V                KeyboardInputGesture.fromName("control+v").send()            except Exception:                try:                    # Try Shift+Insert as alternative                    KeyboardInputGesture.fromName("shift+insert").send()                except Exception:                    # Last resort: use WM_PASTE if we have a window handle                    if hasattr(focus, 'windowHandle') and focus.windowHandle:                        WM_PASTE = 0x0302                        watchdog.cancellableSendMessage(focus.windowHandle, WM_PASTE, 0, 0)                    else:                        # If all else fails, focus might be in a non-standard control                        try:                            focus.setFocus()                            time.sleep(0.05)                            KeyboardInputGesture.fromName("control+v").send()                        except Exception:                            ui.message(_("ไม่สามารถวางคำได้ กรุณาลองวางด้วยตนเอง (Ctrl+V)"))                        if clipboardBackup is not None:                core.callLater(300, lambda: api.copyToClip(clipboardBackup))                            ui.message(_("แทนที่ด้วยคำว่า: {}").format(newWord))                    except Exception as e:            ui.message(_("ไม่สามารถแทนที่คำได้: {}").format(str(e)))            log.error(f"Error in replaceWord: {e}")    def _showDialog_safe(self, suggestions, replace_word_callback):        # Pass the main frame as parent for proper dialog management        dialog = WordSuggestionDialog(gui.mainFrame, _("คำใกล้เคียง"), suggestions, replace_word_callback)        dialog.ShowModal()        dialog.Destroy()            def getWordSuggestions(self, word):        suggestions = []        word = word.strip()                if not word:            return suggestions                    # Case-insensitive check for words starting with the input word        # In Thai, case is usually not an issue, but using startswith is key.        for dict_word in self.dictionary.keys():            if dict_word.startswith(word):                suggestions.append(dict_word)                # Return unique and sorted suggestions, limited to 15 entries        return sorted(list(set(suggestions)))[:15]    def spellWord(self, word):        """Spell the given word character by character, separating consonants, vowels, and tone marks"""        if not word:            ui.message(_("ไม่มีคำให้สะกด"))            return                    # Define Thai character ranges        consonants = r'[ก-ฮ]'        vowels = r'[ะาๅิีึืุูเแโใไ]'        tone_marks = r'[่้๊๋]'                def get_char_type(char):            if re.match(consonants, char):                return "", char            elif re.match(vowels, char):                return "", {                    'ะ': 'สระอะ', 'า': 'สระอา', 'ๅ': 'สระอา (ยาว)',                     'ิ': 'สระอิ', 'ี': 'สระอี', 'ึ': 'สระอึ', 'ื': 'สระอื',                     'ุ': 'สระอุ', 'ู': 'สระอู', 'เ': 'สระเอ', 'แ': 'สระแอ',                     'โ': 'สระโอ', 'ใ': 'สระใอ', 'ไ': 'สระไอ'                }.get(char, f"สระ {char}")            elif re.match(tone_marks, char):                return "", {                    '่': 'ไม้เอก', '้': 'ไม้โท', '๊': 'ไม้ตรี', '๋': 'ไม้จัตวา'                }.get(char, f"วรรณยุกต์ {char}")            else:                return "", char        spelled_chars = []        for char in word:            char_type, char_name = get_char_type(char)            spelled_chars.append(char_name)                # Combine characters with comma for a single speech call        spelled_text = ",".join(spelled_chars)        # Flush speech queue to ensure no prior speech is buffered        speech.cancelSpeech()        speech.speak([spelled_text])class WordSuggestionDialog(wx.Dialog):    def __init__(self, parent, title, suggestions, on_replace_callback):        super(WordSuggestionDialog, self).__init__(parent, title=title, size=(400, 300))        self.suggestions = suggestions        self.selected_word = None        self.on_replace_callback = on_replace_callback         self.main_sizer = wx.BoxSizer(wx.VERTICAL)        self.create_controls()        self.SetSizer(self.main_sizer)        self.CentreOnScreen()        self.Raise()        self.SetFocus()    def create_controls(self):        self.suggestion_list = wx.ListBox(self, choices=self.suggestions, style=wx.LB_SINGLE)        if self.suggestions:            self.suggestion_list.SetSelection(0)        self.suggestion_list.Bind(wx.EVT_LISTBOX_DCLICK, self.on_double_click)        self.suggestion_list.Bind(wx.EVT_KEY_DOWN, self.on_list_key_down)        self.main_sizer.Add(self.suggestion_list, 1, wx.EXPAND | wx.ALL, 5)        button_sizer = wx.BoxSizer(wx.HORIZONTAL)        ok_button = wx.Button(self, wx.ID_OK, label=_("ตกลง"))        ok_button.Bind(wx.EVT_BUTTON, self.on_ok)        cancel_button = wx.Button(self, wx.ID_CANCEL, label=_("ยกเลิก"))        cancel_button.Bind(wx.EVT_BUTTON, lambda evt: self.EndModal(wx.ID_CANCEL))        button_sizer.Add(ok_button, 0, wx.ALL, 5)        button_sizer.Add(cancel_button, 0, wx.ALL, 5)        self.main_sizer.Add(button_sizer, 0, wx.ALIGN_CENTER | wx.ALL, 5)        self.Bind(wx.EVT_CHAR_HOOK, self.on_char_hook)                if self.suggestions:            ui.message(_("พบ {} คำแนะนำ: {}").format(len(self.suggestions), self.suggestions[0]))            braille.handler.message(_("พบ {} คำแนะนำ").format(len(self.suggestions)))    def on_list_key_down(self, event):        key_code = event.GetKeyCode()        if key_code == wx.WXK_RETURN:            self.on_ok(event)        else:            event.Skip()    def on_ok(self, event):        selection = self.suggestion_list.GetSelection()        if selection != wx.NOT_FOUND:            self.selected_word = self.suggestions[selection]            # Hide dialog first before pasting            self.Hide()            wx.CallLater(50, self.execute_paste)        else:            ui.message(_("กรุณาเลือกคำ"))    def execute_paste(self):        """Execute the paste operation after dialog is hidden, using xBlock's robust method"""        try:            # Backup clipboard            try:                clipboardBackup = api.getClipData()            except OSError:                clipboardBackup = None                        # Copy selected word to clipboard            try:                api.copyToClip(self.selected_word)                time.sleep(0.1 if clipboardBackup is None else 0.01)                api.processPendingEvents(False)            except Exception as e:                log.error(f"Error copying to clipboard: {e}")                ui.message(_("ไม่สามารถคัดลอกคำไปยังคลิปบอร์ดได้"))                self.EndModal(wx.ID_CANCEL)                return                        # Paste the word using xBlock's robust method            focus = api.getFocusObject()            try:                if hasattr(focus, 'windowClassName') and focus.windowClassName == "ConsoleWindowClass":                    # Windows console window - Control+V doesn't work here                    WM_COMMAND = 0x0111                    watchdog.cancellableSendMessage(focus.windowHandle, WM_COMMAND, 0xfff1, 0)                elif hasattr(focus, 'windowClassName') and "Rich" in focus.windowClassName and "Text" in focus.windowClassName:                    # Rich Text controls - use WM_PASTE message                    WM_PASTE = 0x0302                    watchdog.cancellableSendMessage(focus.windowHandle, WM_PASTE, 0, 0)                else:                    # For other windows, try multiple methods                    try:                        # First try standard Ctrl+V                        KeyboardInputGesture.fromName("control+v").send()                    except Exception:                        try:                            # Try Shift+Insert as alternative                            KeyboardInputGesture.fromName("shift+insert").send()                        except Exception:                            # Last resort: use WM_PASTE if we have a window handle                            if hasattr(focus, 'windowHandle') and focus.windowHandle:                                WM_PASTE = 0x0302                                watchdog.cancellableSendMessage(focus.windowHandle, WM_PASTE, 0, 0)                            else:                                # If all else fails, focus might be in a non-standard control                                try:                                    focus.setFocus()                                    time.sleep(0.05)                                    KeyboardInputGesture.fromName("control+v").send()                                except Exception:                                    log.error("Failed to paste text in non-standard control")                                    ui.message(_("ไม่สามารถวางคำได้ กรุณาลองวางด้วยตนเอง (Ctrl+V)"))                                    self.EndModal(wx.ID_CANCEL)                                    return                            # Restore clipboard                if clipboardBackup is not None:                    core.callLater(300, lambda: api.copyToClip(clipboardBackup))                                ui.message(_("แทนที่ด้วยคำว่า: {}").format(self.selected_word))                self.EndModal(wx.ID_OK)                        except Exception as e:                log.error(f"Error pasting text: {e}")                ui.message(_("ไม่สามารถแทนที่คำได้: {}").format(str(e)))                self.EndModal(wx.ID_CANCEL)                except Exception as e:            log.error(f"Unexpected error in execute_paste: {e}")            ui.message(_("เกิดข้อผิดพลาดที่ไม่คาดคิด: {}").format(str(e)))            self.EndModal(wx.ID_CANCEL)    def on_double_click(self, event):        self.on_ok(event)    def on_char_hook(self, event):        key = event.GetKeyCode()        if key == wx.WXK_RETURN:            if self.suggestion_list.GetSelection() != wx.NOT_FOUND:                self.on_ok(event)        elif key == wx.WXK_ESCAPE:            self.EndModal(wx.ID_CANCEL)        else:            event.Skip()